// -*-c++-*-
#include "copyright.h"

// Define the block's atom capacity, in a manner similar to what was done in valence_potential.cui.
#ifdef VSITE_STANDALONE
#  define EXCL_GMEM_OFFSET  (blockIdx.x * gmem_r.max_atoms)
#  ifdef TCALC_IS_SINGLE
#    if VSITE_STANDALONE_THREAD_COUNT == 64
#      define VALENCE_ATOM_CAPACITY eighth_valence_work_unit_atoms
#    elif VSITE_STANDALONE_THREAD_COUNT <= 128
#      define VALENCE_ATOM_CAPACITY quarter_valence_work_unit_atoms
#    elif VSITE_STANDALONE_THREAD_COUNT <= 256
#      define VALENCE_ATOM_CAPACITY half_valence_work_unit_atoms
#    else
#      define VALENCE_ATOM_CAPACITY maximum_valence_work_unit_atoms
#    endif
#  else
#    define VALENCE_ATOM_CAPACITY maximum_valence_work_unit_atoms
#  endif
#endif

// The "standalone" pre-processor directive constructs a separate kernel to implement the virtual
// site placement.  Without the standalone directive, the code still assumes the availability of
// critical variables, including a phase space synthesis writeable abstract named poly_psw, a
// const valence kit (which includes valence work units and imported atom maps) named poly_vk,
// and a cache resource kit named gmem_r.
#ifdef VSITE_STANDALONE
__global__ void	__launch_bounds__(VSITE_STANDALONE_THREAD_COUNT, VSITE_STANDALONE_BLOCK_MULTIPLIER)
KERNEL_NAME(PsSynthesisWriter poly_psw, const SyValenceKit<TCALC> poly_vk,
            const SyAtomUpdateKit<TCALC, TCALC2, TCALC4> poly_auk,
            CacheResourceKit<TCALC> gmem_r) {
  __shared__ int2 vwu_map[vwu_abstract_length];
  __shared__ int vwu_task_count[vwu_abstract_length];
  __shared__ int vwu_padded_task_count[vwu_abstract_length];
  __shared__ int vwu_idx;
#  ifdef SPLIT_FORCE_ACCUMULATION
#    ifdef TCALC_IS_SINGLE
  __shared__ int sh_xfrc[VALENCE_ATOM_CAPACITY];
  __shared__ int sh_yfrc[VALENCE_ATOM_CAPACITY];
  __shared__ int sh_zfrc[VALENCE_ATOM_CAPACITY];
#    else
  __shared__ llint sh_xfrc[VALENCE_ATOM_CAPACITY];
  __shared__ llint sh_yfrc[VALENCE_ATOM_CAPACITY];
  __shared__ llint sh_zfrc[VALENCE_ATOM_CAPACITY];
#    endif
  __shared__ int sh_xfrc_overflow[VALENCE_ATOM_CAPACITY];
  __shared__ int sh_yfrc_overflow[VALENCE_ATOM_CAPACITY];
  __shared__ int sh_zfrc_overflow[VALENCE_ATOM_CAPACITY];
#  else
  __shared__ llint sh_xfrc[VALENCE_ATOM_CAPACITY];
  __shared__ llint sh_yfrc[VALENCE_ATOM_CAPACITY];
  __shared__ llint sh_zfrc[VALENCE_ATOM_CAPACITY];
#  endif
  if (threadIdx.x == 0) {
    vwu_idx = blockIdx.x;
  }
  __syncthreads();
  while (vwu_idx < poly_vk.nvwu) {

    // The instruction set map is read and stored in __shared__ for convenience, and to ensure
    // that it never leaves cache.  The instructions themselves are "streamed," which for purposes
    // of this documentation means read from global, used once, and not cached.  Each block must be
    // at least vwu_abstract_length + warp_size_int in size.  Currently, that is 64 on NVIDIA GPUs,
    // 128 on commodity AMD GPUs, and only 64 on Intel GPUs.
    if (threadIdx.x < vwu_abstract_length) {
      vwu_map[threadIdx.x] = __ldcv(&poly_vk.vwu_abstracts[(vwu_idx * vwu_abstract_length) +
                                                           threadIdx.x]);
      vwu_task_count[threadIdx.x] = vwu_map[threadIdx.x].y - vwu_map[threadIdx.x].x;
      vwu_padded_task_count[threadIdx.x] = devcRoundUp(vwu_task_count[threadIdx.x], warp_size_int);
    }
    __syncthreads();

    // Skip if this work unit involves no virtual sites.
    if (vwu_task_count[(size_t)(VwuAbstractMap::VSITE)] == 0) {
      if (threadIdx.x == 0) {
        vwu_idx += gridDim.x;
      }
      __syncthreads();
      continue;
    }

    // Import atomic coordinates.  This employs all threads of the block, breaking up each set of
    // information at the warp level.
    const int import_llim = vwu_map[(size_t)(VwuAbstractMap::IMPORT)].x;
    const int import_hlim = vwu_map[(size_t)(VwuAbstractMap::IMPORT)].y;
    const int import_count  = import_hlim - import_llim;
    const int import_stride = devcRoundUp(import_hlim - import_llim, warp_size_int);
    int pos = threadIdx.x;
    while (pos < import_stride) {
      if (pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + pos]);
#  ifdef SPLIT_FORCE_ACCUMULATION
#    ifdef TCALC_IS_SINGLE
        const int2 x_tmp = longlongToInt63(__ldcv(&poly_psw.xalt[read_idx]));
        sh_xfrc[pos]          = x_tmp.x;
        sh_xfrc_overflow[pos] = x_tmp.y;
#    else
        sh_xfrc[pos]          = __ldcv(&poly_psw.xalt[read_idx]);
        sh_xfrc_overflow[pos] = __ldcv(&poly_psw.xalt_ovrf[read_idx]);
#    endif
#  else
        sh_xfrc[pos] = __ldcv(&poly_psw.xalt[read_idx]);
#  endif
      }
      pos += blockDim.x;
    }
    while (pos < 2 * import_stride) {
      const int rel_pos = pos - import_stride;
      if (rel_pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + rel_pos]);
#  ifdef SPLIT_FORCE_ACCUMULATION
#    ifdef TCALC_IS_SINGLE
        const int2 y_tmp = longlongToInt63(__ldcv(&poly_psw.yalt[read_idx]));
        sh_yfrc[rel_pos]          = y_tmp.x;
        sh_yfrc_overflow[rel_pos] = y_tmp.y;
#    else
        sh_yfrc[rel_pos]          = __ldcv(&poly_psw.yalt[read_idx]);
        sh_yfrc_overflow[rel_pos] = __ldcv(&poly_psw.yalt_ovrf[read_idx]);
#    endif
#  else
        sh_yfrc[rel_pos] = __ldcv(&poly_psw.yalt[read_idx]);
#  endif
      }
      pos += blockDim.x;
    }
    while (pos < 3 * import_stride) {
      const int rel_pos = pos - (2 * import_stride);
      if (rel_pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + rel_pos]);
#  ifdef SPLIT_FORCE_ACCUMULATION
#    ifdef TCALC_IS_SINGLE
        const int2 z_tmp = longlongToInt63(__ldcv(&poly_psw.zalt[read_idx]));
        sh_zfrc[rel_pos]          = z_tmp.x;
        sh_zfrc_overflow[rel_pos] = z_tmp.y;
#    else
        sh_zfrc[rel_pos]          = __ldcv(&poly_psw.zalt[read_idx]);
        sh_zfrc_overflow[rel_pos] = __ldcv(&poly_psw.zalt_ovrf[read_idx]);
#    endif
#  else
        sh_zfrc[rel_pos] = __ldcv(&poly_psw.zalt[read_idx]);
#  endif
      }
      pos += blockDim.x;
    }
    __syncthreads();
    int vterm_limit;
#endif // VSITE_STANDALONE is defined

    // Similar to the process with valence interaction terms, loop over all virtual site frames.
    pos = threadIdx.x;
    vterm_limit = vwu_padded_task_count[(size_t)(VwuAbstractMap::VSITE)];
    while (pos < vterm_limit) {
      if (pos < vwu_task_count[(size_t)(VwuAbstractMap::VSITE)]) {

        // Obtain the instruction
        const int task_offset = vwu_map[(size_t)(VwuAbstractMap::VSITE)].x;
        const uint2 tinsr = __ldcv(&poly_auk.vste_insr[task_offset + pos]);
        const int vs_atom = (tinsr.x & 0x3ff);
        const int parent_atom = ((tinsr.x >> 10) & 0x3ff);
        const int frame2_atom = ((tinsr.x >> 20) & 0x3ff);
        const int fr_param_idx = ((tinsr.y >> 20) & 0xfff);
        const TCALC4 fr_details = poly_auk.vs_params[fr_param_idx];
        const VirtualSiteKind kind = static_cast<VirtualSiteKind>(fr_details.w);
        
        // A switch over all types of virtual site frames
        switch (kind) {
        case VirtualSiteKind::FLEX_2:
        case VirtualSiteKind::FIXED_2:
          {
            // Multiplying by the inverse position scaling constant, only to multiply each number
            // by the scaling constant, is unecessary and will not preserve any extra precision in
            // any of the virtual site placements.
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const TCALC dx = int63SumToFloat( sh_xfrc[frame2_atom],
                                              sh_xfrc_overflow[frame2_atom],
                                             -sh_xfrc[parent_atom],
                                             -sh_xfrc_overflow[parent_atom]);
            const TCALC dy = int63SumToFloat( sh_yfrc[frame2_atom],
                                              sh_yfrc_overflow[frame2_atom],
                                             -sh_yfrc[parent_atom],
                                             -sh_yfrc_overflow[parent_atom]);
            const TCALC dz = int63SumToFloat( sh_zfrc[frame2_atom],
                                              sh_zfrc_overflow[frame2_atom],
                                             -sh_zfrc[parent_atom],
                                             -sh_zfrc_overflow[parent_atom]);
#  else
            const TCALC dx = int95SumToDouble( sh_xfrc[frame2_atom],
                                               sh_xfrc_overflow[frame2_atom],
                                              -sh_xfrc[parent_atom],
                                              -sh_xfrc_overflow[parent_atom]);
            const TCALC dy = int95SumToDouble( sh_yfrc[frame2_atom],
                                               sh_yfrc_overflow[frame2_atom],
                                              -sh_yfrc[parent_atom],
                                              -sh_yfrc_overflow[parent_atom]);
            const TCALC dz = int95SumToDouble( sh_zfrc[frame2_atom],
                                               sh_zfrc_overflow[frame2_atom],
                                              -sh_zfrc[parent_atom],
                                              -sh_zfrc_overflow[parent_atom]);
#  endif
#else
            const TCALC dx = sh_xfrc[frame2_atom] - sh_xfrc[parent_atom];
            const TCALC dy = sh_yfrc[frame2_atom] - sh_yfrc[parent_atom];
            const TCALC dz = sh_zfrc[frame2_atom] - sh_zfrc[parent_atom];
#endif
            const TCALC disp_mult = (kind == VirtualSiteKind::FLEX_2) ?
                                    fr_details.x : fr_details.x * poly_psw.gpos_scale_f /
                                                   SQRT_FUNC((dx * dx) + (dy * dy) + (dz * dz));
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const int2 vs_x = int63Sum(sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom],
                                       disp_mult * dx);
            const int2 vs_y = int63Sum(sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom],
                                       disp_mult * dy);
            const int2 vs_z = int63Sum(sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom],
                                       disp_mult * dz);
#  else
            const int95_t vs_x = int95Sum(sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom],
                                          disp_mult * dx);
            const int95_t vs_y = int95Sum(sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom],
                                          disp_mult * dy);
            const int95_t vs_z = int95Sum(sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom],
                                          disp_mult * dz);
#  endif
            sh_xfrc[vs_atom]          = vs_x.x;
            sh_yfrc[vs_atom]          = vs_y.x;
            sh_zfrc[vs_atom]          = vs_z.x;
            sh_xfrc_overflow[vs_atom] = vs_x.y;
            sh_yfrc_overflow[vs_atom] = vs_y.y;
            sh_zfrc_overflow[vs_atom] = vs_z.y;
#else
            sh_xfrc[vs_atom] = sh_xfrc[parent_atom] + LLCONV_FUNC(dx * disp_mult);
            sh_yfrc[vs_atom] = sh_yfrc[parent_atom] + LLCONV_FUNC(dy * disp_mult);
            sh_zfrc[vs_atom] = sh_zfrc[parent_atom] + LLCONV_FUNC(dz * disp_mult);
#endif
          }
          break;
        case VirtualSiteKind::FLEX_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff);
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const TCALC p_f2x = int63SumToFloat( sh_xfrc[frame2_atom],
                                                 sh_xfrc_overflow[frame2_atom],
                                                -sh_xfrc[parent_atom],
                                                -sh_xfrc_overflow[parent_atom]);
            const TCALC p_f2y = int63SumToFloat( sh_yfrc[frame2_atom],
                                                 sh_yfrc_overflow[frame2_atom],
                                                -sh_yfrc[parent_atom],
                                                -sh_yfrc_overflow[parent_atom]);
            const TCALC p_f2z = int63SumToFloat( sh_zfrc[frame2_atom],
                                                 sh_zfrc_overflow[frame2_atom],
                                                -sh_zfrc[parent_atom],
                                                -sh_zfrc_overflow[parent_atom]);
            const TCALC p_f3x = int63SumToFloat( sh_xfrc[frame3_atom],
                                                 sh_xfrc_overflow[frame3_atom],
                                                -sh_xfrc[parent_atom],
                                                -sh_xfrc_overflow[parent_atom]);
            const TCALC p_f3y = int63SumToFloat( sh_yfrc[frame3_atom],
                                                 sh_yfrc_overflow[frame3_atom],
                                                -sh_yfrc[parent_atom],
                                                -sh_yfrc_overflow[parent_atom]);
            const TCALC p_f3z = int63SumToFloat( sh_zfrc[frame3_atom],
                                                 sh_zfrc_overflow[frame3_atom],
                                                -sh_zfrc[parent_atom],
                                                -sh_zfrc_overflow[parent_atom]);
            const int2 vs_xarm = floatToInt63((p_f2x * fr_details.x) + (p_f3x * fr_details.y));
            const int2 vs_yarm = floatToInt63((p_f2y * fr_details.x) + (p_f3y * fr_details.y));
            const int2 vs_zarm = floatToInt63((p_f2z * fr_details.x) + (p_f3z * fr_details.y));
            const int2 nvs_x = splitFPSum(vs_xarm,
                                          sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom]);
            const int2 nvs_y = splitFPSum(vs_yarm,
                                          sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom]);
            const int2 nvs_z = splitFPSum(vs_zarm,
                                          sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom]);
#  else
            const TCALC p_f2x = int95SumToDouble( sh_xfrc[frame2_atom],
                                                  sh_xfrc_overflow[frame2_atom],
                                                 -sh_xfrc[parent_atom],
                                                 -sh_xfrc_overflow[parent_atom]);
            const TCALC p_f2y = int95SumToDouble( sh_yfrc[frame2_atom],
                                                  sh_yfrc_overflow[frame2_atom],
                                                 -sh_yfrc[parent_atom],
                                                 -sh_yfrc_overflow[parent_atom]);
            const TCALC p_f2z = int95SumToDouble( sh_zfrc[frame2_atom],
                                                  sh_zfrc_overflow[frame2_atom],
                                                 -sh_zfrc[parent_atom],
                                                 -sh_zfrc_overflow[parent_atom]);
            const TCALC p_f3x = int95SumToDouble( sh_xfrc[frame3_atom],
                                                  sh_xfrc_overflow[frame3_atom],
                                                 -sh_xfrc[parent_atom],
                                                 -sh_xfrc_overflow[parent_atom]);
            const TCALC p_f3y = int95SumToDouble( sh_yfrc[frame3_atom],
                                                  sh_yfrc_overflow[frame3_atom],
                                                 -sh_yfrc[parent_atom],
                                                 -sh_yfrc_overflow[parent_atom]);
            const TCALC p_f3z = int95SumToDouble( sh_zfrc[frame3_atom],
                                                  sh_zfrc_overflow[frame3_atom],
                                                 -sh_zfrc[parent_atom],
                                                 -sh_zfrc_overflow[parent_atom]);
            const int95_t vs_xarm = doubleToInt95((p_f2x * fr_details.x) + (p_f3x * fr_details.y));
            const int95_t vs_yarm = doubleToInt95((p_f2y * fr_details.x) + (p_f3y * fr_details.y));
            const int95_t vs_zarm = doubleToInt95((p_f2z * fr_details.x) + (p_f3z * fr_details.y));
            const int95_t nvs_x = splitFPSum(vs_xarm,
                                             sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom]);
            const int95_t nvs_y = splitFPSum(vs_yarm,
                                             sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom]);
            const int95_t nvs_z = splitFPSum(vs_zarm,
                                             sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom]);
#  endif
            sh_xfrc[vs_atom] = nvs_x.x;
            sh_yfrc[vs_atom] = nvs_y.x;
            sh_zfrc[vs_atom] = nvs_z.x;
            sh_xfrc_overflow[vs_atom] = nvs_x.y;
            sh_yfrc_overflow[vs_atom] = nvs_y.y;
            sh_zfrc_overflow[vs_atom] = nvs_z.y;
#else
            const TCALC p_f2x = (TCALC)(sh_xfrc[frame2_atom] - sh_xfrc[parent_atom]);
            const TCALC p_f2y = (TCALC)(sh_yfrc[frame2_atom] - sh_yfrc[parent_atom]);
            const TCALC p_f2z = (TCALC)(sh_zfrc[frame2_atom] - sh_zfrc[parent_atom]);
            const TCALC p_f3x = (TCALC)(sh_xfrc[frame3_atom] - sh_xfrc[parent_atom]);
            const TCALC p_f3y = (TCALC)(sh_yfrc[frame3_atom] - sh_yfrc[parent_atom]);
            const TCALC p_f3z = (TCALC)(sh_zfrc[frame3_atom] - sh_zfrc[parent_atom]);            
            sh_xfrc[vs_atom] = sh_xfrc[parent_atom] + LLCONV_FUNC((p_f2x * fr_details.x) +
                                                                  (p_f3x * fr_details.y));
            sh_yfrc[vs_atom] = sh_yfrc[parent_atom] + LLCONV_FUNC((p_f2y * fr_details.x) +
                                                                  (p_f3y * fr_details.y));
            sh_zfrc[vs_atom] = sh_zfrc[parent_atom] + LLCONV_FUNC((p_f2z * fr_details.x) +
                                                                  (p_f3z * fr_details.y));
#endif
          }
          break;
        case VirtualSiteKind::FIXED_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff);
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const TCALC f2_f3x = int63SumToFloat( sh_xfrc[frame3_atom],
                                                  sh_xfrc_overflow[frame3_atom],
                                                 -sh_xfrc[frame2_atom],
                                                 -sh_xfrc_overflow[frame2_atom]);
            const TCALC f2_f3y = int63SumToFloat( sh_yfrc[frame3_atom],
                                                  sh_yfrc_overflow[frame3_atom],
                                                 -sh_yfrc[frame2_atom],
                                                 -sh_yfrc_overflow[frame2_atom]);
            const TCALC f2_f3z = int63SumToFloat( sh_zfrc[frame3_atom],
                                                  sh_zfrc_overflow[frame3_atom],
                                                 -sh_zfrc[frame2_atom],
                                                 -sh_zfrc_overflow[frame2_atom]);
            const int2 midpt_x = int63Sum(sh_xfrc[frame2_atom], sh_xfrc_overflow[frame2_atom],
                                          fr_details.y * f2_f3x);
            const int2 midpt_y = int63Sum(sh_yfrc[frame2_atom], sh_yfrc_overflow[frame2_atom],
                                          fr_details.y * f2_f3y);
            const int2 midpt_z = int63Sum(sh_zfrc[frame2_atom], sh_zfrc_overflow[frame2_atom],
                                          fr_details.y * f2_f3z);
            const TCALC dmx = int63SumToFloat(midpt_x.x, midpt_x.y, -sh_xfrc[parent_atom],
                                              -sh_xfrc_overflow[parent_atom]);
            const TCALC dmy = int63SumToFloat(midpt_y.x, midpt_y.y, -sh_yfrc[parent_atom],
                                              -sh_yfrc_overflow[parent_atom]);
            const TCALC dmz = int63SumToFloat(midpt_z.x, midpt_z.y, -sh_zfrc[parent_atom],
                                              -sh_zfrc_overflow[parent_atom]);
#  else
            const TCALC f2_f3x = int95SumToDouble( sh_xfrc[frame3_atom],
                                                   sh_xfrc_overflow[frame3_atom],
                                                  -sh_xfrc[frame2_atom],
                                                  -sh_xfrc_overflow[frame2_atom]);
            const TCALC f2_f3y = int95SumToDouble( sh_yfrc[frame3_atom],
                                                   sh_yfrc_overflow[frame3_atom],
                                                  -sh_yfrc[frame2_atom],
                                                  -sh_yfrc_overflow[frame2_atom]);
            const TCALC f2_f3z = int95SumToDouble( sh_zfrc[frame3_atom],
                                                   sh_zfrc_overflow[frame3_atom],
                                                  -sh_zfrc[frame2_atom],
                                                  -sh_zfrc_overflow[frame2_atom]);
            const int95_t midpt_x = int95Sum(sh_xfrc[frame2_atom], sh_xfrc_overflow[frame2_atom],
                                             fr_details.y * f2_f3x);
            const int95_t midpt_y = int95Sum(sh_yfrc[frame2_atom], sh_yfrc_overflow[frame2_atom],
                                             fr_details.y * f2_f3y);
            const int95_t midpt_z = int95Sum(sh_zfrc[frame2_atom], sh_zfrc_overflow[frame2_atom],
                                             fr_details.y * f2_f3z);
            const TCALC dmx = int95SumToDouble(midpt_x.x, midpt_x.y, -sh_xfrc[parent_atom],
                                              -sh_xfrc_overflow[parent_atom]);
            const TCALC dmy = int95SumToDouble(midpt_y.x, midpt_y.y, -sh_yfrc[parent_atom],
                                              -sh_yfrc_overflow[parent_atom]);
            const TCALC dmz = int95SumToDouble(midpt_z.x, midpt_z.y, -sh_zfrc[parent_atom],
                                              -sh_zfrc_overflow[parent_atom]);
#  endif
#else
            const TCALC f2_f3x = (TCALC)(sh_xfrc[frame3_atom] - sh_xfrc[frame2_atom]);
            const TCALC f2_f3y = (TCALC)(sh_yfrc[frame3_atom] - sh_yfrc[frame2_atom]);
            const TCALC f2_f3z = (TCALC)(sh_zfrc[frame3_atom] - sh_zfrc[frame2_atom]);
            const llint midpt_x = sh_xfrc[frame2_atom] + LLCONV_FUNC(fr_details.y * f2_f3x);
            const llint midpt_y = sh_yfrc[frame2_atom] + LLCONV_FUNC(fr_details.y * f2_f3y);
            const llint midpt_z = sh_zfrc[frame2_atom] + LLCONV_FUNC(fr_details.y * f2_f3z);
            const TCALC dmx = (TCALC)(midpt_x - sh_xfrc[parent_atom]);
            const TCALC dmy = (TCALC)(midpt_y - sh_yfrc[parent_atom]);
            const TCALC dmz = (TCALC)(midpt_z - sh_zfrc[parent_atom]);
#endif
            // The same normalization is required as in the case of the FLEX_3 frame.
            const TCALC disp_mult = fr_details.x * poly_psw.gpos_scale /
                                    SQRT_FUNC((dmx * dmx) + (dmy * dmy) + (dmz * dmz));
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const int2 vs_x = int63Sum(sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom],
                                       disp_mult * dmx);
            const int2 vs_y = int63Sum(sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom],
                                       disp_mult * dmy);
            const int2 vs_z = int63Sum(sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom],
                                       disp_mult * dmz);
#  else
            const int95_t vs_x = int95Sum(sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom],
                                          disp_mult * dmx);
            const int95_t vs_y = int95Sum(sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom],
                                          disp_mult * dmy);
            const int95_t vs_z = int95Sum(sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom],
                                          disp_mult * dmz);
#  endif
            sh_xfrc[vs_atom]          = vs_x.x;
            sh_yfrc[vs_atom]          = vs_y.x;
            sh_zfrc[vs_atom]          = vs_z.x;
            sh_xfrc_overflow[vs_atom] = vs_x.y;
            sh_yfrc_overflow[vs_atom] = vs_y.y;
            sh_zfrc_overflow[vs_atom] = vs_z.y;
#else
            sh_xfrc[vs_atom] = sh_xfrc[parent_atom] + LLCONV_FUNC(disp_mult * dmx);
            sh_yfrc[vs_atom] = sh_yfrc[parent_atom] + LLCONV_FUNC(disp_mult * dmy);
            sh_zfrc[vs_atom] = sh_zfrc[parent_atom] + LLCONV_FUNC(disp_mult * dmz);
#endif
          }
          break;
        case VirtualSiteKind::FAD_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff);
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const TCALC3 p_f2 = {
              int63SumToFloat( sh_xfrc[frame2_atom],  sh_xfrc_overflow[frame2_atom],
                              -sh_xfrc[parent_atom], -sh_xfrc_overflow[parent_atom]),
              int63SumToFloat( sh_yfrc[frame2_atom],  sh_yfrc_overflow[frame2_atom],
                              -sh_yfrc[parent_atom], -sh_yfrc_overflow[parent_atom]),
              int63SumToFloat( sh_zfrc[frame2_atom],  sh_zfrc_overflow[frame2_atom],
                              -sh_zfrc[parent_atom], -sh_zfrc_overflow[parent_atom])
            };
            const TCALC3 f2_f3 = {
              int63SumToFloat( sh_xfrc[frame3_atom],  sh_xfrc_overflow[frame3_atom],
                              -sh_xfrc[frame2_atom], -sh_xfrc_overflow[frame2_atom]),
              int63SumToFloat( sh_yfrc[frame3_atom],  sh_yfrc_overflow[frame3_atom],
                              -sh_yfrc[frame2_atom], -sh_yfrc_overflow[frame2_atom]),
              int63SumToFloat( sh_zfrc[frame3_atom],  sh_zfrc_overflow[frame3_atom],
                              -sh_zfrc[frame2_atom], -sh_zfrc_overflow[frame2_atom])
            };
#  else
            const TCALC3 p_f2 = {
              int95SumToDouble( sh_xfrc[frame2_atom],  sh_xfrc_overflow[frame2_atom],
                               -sh_xfrc[parent_atom], -sh_xfrc_overflow[parent_atom]),
              int95SumToDouble( sh_yfrc[frame2_atom],  sh_yfrc_overflow[frame2_atom],
                               -sh_yfrc[parent_atom], -sh_yfrc_overflow[parent_atom]),
              int95SumToDouble( sh_zfrc[frame2_atom],  sh_zfrc_overflow[frame2_atom],
                               -sh_zfrc[parent_atom], -sh_zfrc_overflow[parent_atom])
            };
            const TCALC3 f2_f3 = {
              int95SumToDouble( sh_xfrc[frame3_atom],  sh_xfrc_overflow[frame3_atom],
                               -sh_xfrc[frame2_atom], -sh_xfrc_overflow[frame2_atom]),
              int95SumToDouble( sh_yfrc[frame3_atom],  sh_yfrc_overflow[frame3_atom],
                               -sh_yfrc[frame2_atom], -sh_yfrc_overflow[frame2_atom]),
              int95SumToDouble( sh_zfrc[frame3_atom],  sh_zfrc_overflow[frame3_atom],
                               -sh_zfrc[frame2_atom], -sh_zfrc_overflow[frame2_atom])
            };
#  endif
#else
            const TCALC3 p_f2  = { (TCALC)(sh_xfrc[frame2_atom] - sh_xfrc[parent_atom]),
                                   (TCALC)(sh_yfrc[frame2_atom] - sh_yfrc[parent_atom]),
                                   (TCALC)(sh_zfrc[frame2_atom] - sh_zfrc[parent_atom]) };
            const TCALC3 f2_f3 = { (TCALC)(sh_xfrc[frame3_atom] - sh_xfrc[frame2_atom]),
                                   (TCALC)(sh_yfrc[frame3_atom] - sh_yfrc[frame2_atom]),
                                   (TCALC)(sh_zfrc[frame3_atom] - sh_zfrc[frame2_atom]) };
#endif
            const TCALC3 f23_t_pf2 = perpendicular(f2_f3, p_f2);
            const TCALC invr_p_f2 = (TCALC)(1.0) / SQRT_FUNC((p_f2.x * p_f2.x) +
                                                             (p_f2.y * p_f2.y) +
                                                             (p_f2.z * p_f2.z));
            const TCALC invr_t = (TCALC)(1.0) / SQRT_FUNC((f23_t_pf2.x * f23_t_pf2.x) +
                                                          (f23_t_pf2.y * f23_t_pf2.y) +
                                                          (f23_t_pf2.z * f23_t_pf2.z));
            const TCALC scaled_dim1 = fr_details.x * poly_psw.gpos_scale;
            const TCALC p_f2_factor = scaled_dim1 * COS_FUNC(fr_details.y) * invr_p_f2;
            const TCALC t_factor    = scaled_dim1 * SIN_FUNC(fr_details.y) * invr_t;
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const int2 vs_x = int63Sum(sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom],
                                       (p_f2_factor * p_f2.x) + (t_factor * f23_t_pf2.x));
            const int2 vs_y = int63Sum(sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom],
                                       (p_f2_factor * p_f2.y) + (t_factor * f23_t_pf2.y));
            const int2 vs_z = int63Sum(sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom],
                                       (p_f2_factor * p_f2.z) + (t_factor * f23_t_pf2.z));
#  else
            const int95_t vs_x = int95Sum(sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom],
                                          (p_f2_factor * p_f2.x) + (t_factor * f23_t_pf2.x));
            const int95_t vs_y = int95Sum(sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom],
                                          (p_f2_factor * p_f2.y) + (t_factor * f23_t_pf2.y));
            const int95_t vs_z = int95Sum(sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom],
                                          (p_f2_factor * p_f2.z) + (t_factor * f23_t_pf2.z));
#  endif
            sh_xfrc[vs_atom]          = vs_x.x;
            sh_yfrc[vs_atom]          = vs_y.x;
            sh_zfrc[vs_atom]          = vs_z.x;
            sh_xfrc_overflow[vs_atom] = vs_x.y;
            sh_yfrc_overflow[vs_atom] = vs_y.y;
            sh_zfrc_overflow[vs_atom] = vs_z.y;
#else
            sh_xfrc[vs_atom] = sh_xfrc[parent_atom] + LLCONV_FUNC((p_f2_factor * p_f2.x) +
                                                                  (t_factor * f23_t_pf2.x));
            sh_yfrc[vs_atom] = sh_yfrc[parent_atom] + LLCONV_FUNC((p_f2_factor * p_f2.y) +
                                                                  (t_factor * f23_t_pf2.y));
            sh_zfrc[vs_atom] = sh_zfrc[parent_atom] + LLCONV_FUNC((p_f2_factor * p_f2.z) +
                                                                  (t_factor * f23_t_pf2.z));
#endif
          }
          break;
        case VirtualSiteKind::OUT_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff);
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const TCALC3 p_f2 = {
              int63SumToFloat( sh_xfrc[frame2_atom],  sh_xfrc_overflow[frame2_atom],
                              -sh_xfrc[parent_atom], -sh_xfrc_overflow[parent_atom]),
              int63SumToFloat( sh_yfrc[frame2_atom],  sh_yfrc_overflow[frame2_atom],
                              -sh_yfrc[parent_atom], -sh_yfrc_overflow[parent_atom]),
              int63SumToFloat( sh_zfrc[frame2_atom],  sh_zfrc_overflow[frame2_atom],
                              -sh_zfrc[parent_atom], -sh_zfrc_overflow[parent_atom])
            };
            const TCALC3 p_f3 = {
              int63SumToFloat( sh_xfrc[frame3_atom],  sh_xfrc_overflow[frame3_atom],
                              -sh_xfrc[parent_atom], -sh_xfrc_overflow[parent_atom]),
              int63SumToFloat( sh_yfrc[frame3_atom],  sh_yfrc_overflow[frame3_atom],
                              -sh_yfrc[parent_atom], -sh_yfrc_overflow[parent_atom]),
              int63SumToFloat( sh_zfrc[frame3_atom],  sh_zfrc_overflow[frame3_atom],
                              -sh_zfrc[parent_atom], -sh_zfrc_overflow[parent_atom])
            };
#  else
            const TCALC3 p_f2 = {
              int95SumToDouble( sh_xfrc[frame2_atom],  sh_xfrc_overflow[frame2_atom],
                               -sh_xfrc[parent_atom], -sh_xfrc_overflow[parent_atom]),
              int95SumToDouble( sh_yfrc[frame2_atom],  sh_yfrc_overflow[frame2_atom],
                               -sh_yfrc[parent_atom], -sh_yfrc_overflow[parent_atom]),
              int95SumToDouble( sh_zfrc[frame2_atom],  sh_zfrc_overflow[frame2_atom],
                               -sh_zfrc[parent_atom], -sh_zfrc_overflow[parent_atom])
            };
            const TCALC3 p_f3 = {
              int95SumToDouble( sh_xfrc[frame3_atom],  sh_xfrc_overflow[frame3_atom],
                               -sh_xfrc[parent_atom], -sh_xfrc_overflow[parent_atom]),
              int95SumToDouble( sh_yfrc[frame3_atom],  sh_yfrc_overflow[frame3_atom],
                               -sh_yfrc[parent_atom], -sh_yfrc_overflow[parent_atom]),
              int95SumToDouble( sh_zfrc[frame3_atom],  sh_zfrc_overflow[frame3_atom],
                               -sh_zfrc[parent_atom], -sh_zfrc_overflow[parent_atom])
            };
#  endif
#else
            const TCALC3 p_f2 = { (TCALC)(sh_xfrc[frame2_atom] - sh_xfrc[parent_atom]),
                                  (TCALC)(sh_yfrc[frame2_atom] - sh_yfrc[parent_atom]),
                                  (TCALC)(sh_zfrc[frame2_atom] - sh_zfrc[parent_atom]) };
            const TCALC3 p_f3 = { (TCALC)(sh_xfrc[frame3_atom] - sh_xfrc[parent_atom]),
                                  (TCALC)(sh_yfrc[frame3_atom] - sh_yfrc[parent_atom]),
                                  (TCALC)(sh_zfrc[frame3_atom] - sh_zfrc[parent_atom]) };
#endif
            const TCALC3 pf2_x_pf3 = crossProduct(p_f2, p_f3);
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const int2 vs_x = int63Sum(sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom],
                                       (fr_details.x * p_f2.x) + (fr_details.y * p_f3.x) +
                                       (fr_details.z * pf2_x_pf3.x * poly_psw.inv_gpos_scale_f));
            const int2 vs_y = int63Sum(sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom],
                                       (fr_details.x * p_f2.y) + (fr_details.y * p_f3.y) +
                                       (fr_details.z * pf2_x_pf3.y * poly_psw.inv_gpos_scale_f));
            const int2 vs_z = int63Sum(sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom],
                                       (fr_details.x * p_f2.z) + (fr_details.y * p_f3.z) +
                                       (fr_details.z * pf2_x_pf3.z * poly_psw.inv_gpos_scale_f));
#  else
            const int95_t vs_x = int95Sum(sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom],
                                          (fr_details.x * p_f2.x) + (fr_details.y * p_f3.x) +
                                          (fr_details.z * pf2_x_pf3.x *
                                           poly_psw.inv_gpos_scale_f));
            const int95_t vs_y = int95Sum(sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom],
                                          (fr_details.x * p_f2.y) + (fr_details.y * p_f3.y) +
                                          (fr_details.z * pf2_x_pf3.y *
                                           poly_psw.inv_gpos_scale_f));
            const int95_t vs_z = int95Sum(sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom],
                                          (fr_details.x * p_f2.z) + (fr_details.y * p_f3.z) +
                                          (fr_details.z * pf2_x_pf3.z *
                                           poly_psw.inv_gpos_scale_f));
#  endif
            sh_xfrc[vs_atom] = vs_x.x;
            sh_yfrc[vs_atom] = vs_y.x;
            sh_zfrc[vs_atom] = vs_z.x;
            sh_xfrc_overflow[vs_atom] = vs_x.y;
            sh_yfrc_overflow[vs_atom] = vs_y.y;
            sh_zfrc_overflow[vs_atom] = vs_z.y;
#else
            sh_xfrc[vs_atom] = sh_xfrc[parent_atom] +
                               LLCONV_FUNC((fr_details.x * p_f2.x) + (fr_details.y * p_f3.x) +
                                           (fr_details.z * pf2_x_pf3.x *
                                            poly_psw.inv_gpos_scale_f));
            sh_yfrc[vs_atom] = sh_yfrc[parent_atom] +
                               LLCONV_FUNC((fr_details.x * p_f2.y) + (fr_details.y * p_f3.y) +
                                           (fr_details.z * pf2_x_pf3.y *
                                            poly_psw.inv_gpos_scale_f));
            sh_zfrc[vs_atom] = sh_zfrc[parent_atom] +
                               LLCONV_FUNC((fr_details.x * p_f2.z) + (fr_details.y * p_f3.z) +
                                           (fr_details.z * pf2_x_pf3.z *
                                            poly_psw.inv_gpos_scale_f));
#endif
          }
          break;
        case VirtualSiteKind::FIXED_4:
          {
            const int frame3_atom = (tinsr.y & 0x3ff);
            const int frame4_atom = ((tinsr.y >> 10) & 0x3ff);
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const TCALC p_f2x = int63SumToFloat( sh_xfrc[frame2_atom],
                                                 sh_xfrc_overflow[frame2_atom],
                                                -sh_xfrc[parent_atom],
                                                -sh_xfrc_overflow[parent_atom]);
            const TCALC p_f2y = int63SumToFloat( sh_yfrc[frame2_atom],
                                                 sh_yfrc_overflow[frame2_atom],
                                                -sh_yfrc[parent_atom],
                                                -sh_yfrc_overflow[parent_atom]);
            const TCALC p_f2z = int63SumToFloat( sh_zfrc[frame2_atom],
                                                 sh_zfrc_overflow[frame2_atom],
                                                -sh_zfrc[parent_atom],
                                                -sh_zfrc_overflow[parent_atom]);
            const TCALC p_f3x = int63SumToFloat( sh_xfrc[frame3_atom],
                                                 sh_xfrc_overflow[frame3_atom],
                                                -sh_xfrc[parent_atom],
                                                -sh_xfrc_overflow[parent_atom]);
            const TCALC p_f3y = int63SumToFloat( sh_yfrc[frame3_atom],
                                                 sh_yfrc_overflow[frame3_atom],
                                                -sh_yfrc[parent_atom],
                                                -sh_yfrc_overflow[parent_atom]);
            const TCALC p_f3z = int63SumToFloat( sh_zfrc[frame3_atom],
                                                 sh_zfrc_overflow[frame3_atom],
                                                -sh_zfrc[parent_atom],
                                                -sh_zfrc_overflow[parent_atom]);
            const TCALC p_f4x = int63SumToFloat( sh_xfrc[frame4_atom],
                                                 sh_xfrc_overflow[frame4_atom],
                                                -sh_xfrc[parent_atom],
                                                -sh_xfrc_overflow[parent_atom]);
            const TCALC p_f4y = int63SumToFloat( sh_yfrc[frame4_atom],
                                                 sh_yfrc_overflow[frame4_atom],
                                                -sh_yfrc[parent_atom],
                                                -sh_yfrc_overflow[parent_atom]);
            const TCALC p_f4z = int63SumToFloat( sh_zfrc[frame4_atom],
                                                 sh_zfrc_overflow[frame4_atom],
                                                -sh_zfrc[parent_atom],
                                                -sh_zfrc_overflow[parent_atom]);
#  else
            const TCALC p_f2x = int95SumToDouble( sh_xfrc[frame2_atom],
                                                  sh_xfrc_overflow[frame2_atom],
                                                 -sh_xfrc[parent_atom],
                                                 -sh_xfrc_overflow[parent_atom]);
            const TCALC p_f2y = int95SumToDouble( sh_yfrc[frame2_atom],
                                                  sh_yfrc_overflow[frame2_atom],
                                                 -sh_yfrc[parent_atom],
                                                 -sh_yfrc_overflow[parent_atom]);
            const TCALC p_f2z = int95SumToDouble( sh_zfrc[frame2_atom],
                                                  sh_zfrc_overflow[frame2_atom],
                                                 -sh_zfrc[parent_atom],
                                                 -sh_zfrc_overflow[parent_atom]);
            const TCALC p_f3x = int95SumToDouble( sh_xfrc[frame3_atom],
                                                  sh_xfrc_overflow[frame3_atom],
                                                 -sh_xfrc[parent_atom],
                                                 -sh_xfrc_overflow[parent_atom]);
            const TCALC p_f3y = int95SumToDouble( sh_yfrc[frame3_atom],
                                                  sh_yfrc_overflow[frame3_atom],
                                                 -sh_yfrc[parent_atom],
                                                 -sh_yfrc_overflow[parent_atom]);
            const TCALC p_f3z = int95SumToDouble( sh_zfrc[frame3_atom],
                                                  sh_zfrc_overflow[frame3_atom],
                                                 -sh_zfrc[parent_atom],
                                                 -sh_zfrc_overflow[parent_atom]);
            const TCALC p_f4x = int95SumToDouble( sh_xfrc[frame4_atom],
                                                  sh_xfrc_overflow[frame4_atom],
                                                 -sh_xfrc[parent_atom],
                                                 -sh_xfrc_overflow[parent_atom]);
            const TCALC p_f4y = int95SumToDouble( sh_yfrc[frame4_atom],
                                                  sh_yfrc_overflow[frame4_atom],
                                                 -sh_yfrc[parent_atom],
                                                 -sh_yfrc_overflow[parent_atom]);
            const TCALC p_f4z = int95SumToDouble( sh_zfrc[frame4_atom],
                                                  sh_zfrc_overflow[frame4_atom],
                                                 -sh_zfrc[parent_atom],
                                                 -sh_zfrc_overflow[parent_atom]);
#  endif
#else
            const TCALC p_f2x = (TCALC)(sh_xfrc[frame2_atom] - sh_xfrc[parent_atom]);
            const TCALC p_f2y = (TCALC)(sh_yfrc[frame2_atom] - sh_yfrc[parent_atom]);
            const TCALC p_f2z = (TCALC)(sh_zfrc[frame2_atom] - sh_zfrc[parent_atom]);
            const TCALC p_f3x = (TCALC)(sh_xfrc[frame3_atom] - sh_xfrc[parent_atom]);
            const TCALC p_f3y = (TCALC)(sh_yfrc[frame3_atom] - sh_yfrc[parent_atom]);
            const TCALC p_f3z = (TCALC)(sh_zfrc[frame3_atom] - sh_zfrc[parent_atom]);
            const TCALC p_f4x = (TCALC)(sh_xfrc[frame4_atom] - sh_xfrc[parent_atom]);
            const TCALC p_f4y = (TCALC)(sh_yfrc[frame4_atom] - sh_yfrc[parent_atom]);
            const TCALC p_f4z = (TCALC)(sh_zfrc[frame4_atom] - sh_zfrc[parent_atom]);
#endif
            const TCALC3 pf3_m_pf2 = { (fr_details.x * p_f3x) - p_f2x,
                                       (fr_details.x * p_f3y) - p_f2y,
                                       (fr_details.x * p_f3z) - p_f2z };
            const TCALC3 pf4_m_pf2 = { (fr_details.y * p_f4x) - p_f2x,
                                       (fr_details.y * p_f4y) - p_f2y,
                                       (fr_details.y * p_f4z) - p_f2z };
            const TCALC3 p_vs = crossProduct(pf3_m_pf2, pf4_m_pf2);
            const TCALC pvs_factor = fr_details.z * poly_psw.gpos_scale /
                                     SQRT_FUNC((p_vs.x * p_vs.x) + (p_vs.y * p_vs.y) +
                                               (p_vs.z * p_vs.z));
#ifdef SPLIT_FORCE_ACCUMULATION
#  ifdef TCALC_IS_SINGLE
            const int2 vs_x = int63Sum(sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom],
                                       pvs_factor * p_vs.x);
            const int2 vs_y = int63Sum(sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom],
                                       pvs_factor * p_vs.y);
            const int2 vs_z = int63Sum(sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom],
                                       pvs_factor * p_vs.z);
#  else
            const int95_t vs_x = int95Sum(sh_xfrc[parent_atom], sh_xfrc_overflow[parent_atom],
                                          pvs_factor * p_vs.x);
            const int95_t vs_y = int95Sum(sh_yfrc[parent_atom], sh_yfrc_overflow[parent_atom],
                                          pvs_factor * p_vs.y);
            const int95_t vs_z = int95Sum(sh_zfrc[parent_atom], sh_zfrc_overflow[parent_atom],
                                          pvs_factor * p_vs.z);
#  endif
            sh_xfrc[vs_atom] = vs_x.x;
            sh_yfrc[vs_atom] = vs_y.x;
            sh_zfrc[vs_atom] = vs_z.x;
            sh_xfrc_overflow[vs_atom] = vs_x.y;
            sh_yfrc_overflow[vs_atom] = vs_y.y;
            sh_zfrc_overflow[vs_atom] = vs_z.y;
#else
            sh_xfrc[vs_atom] = sh_xfrc[parent_atom] + LLCONV_FUNC(pvs_factor * p_vs.x);
            sh_yfrc[vs_atom] = sh_yfrc[parent_atom] + LLCONV_FUNC(pvs_factor * p_vs.y);
            sh_zfrc[vs_atom] = sh_zfrc[parent_atom] + LLCONV_FUNC(pvs_factor * p_vs.z);
#endif
          }
          break;
        case VirtualSiteKind::NONE:
          break;
        }
      
        // With the virtual site's position now committed to the block's private memory space,
        // the question is whether to also copy the results to the global memory arrays.  This
        // will happen as part of the general position update if the placement is part of a
        // broader valence work unit, but should happen here, when the index of the virtual site
        // is at hand and each warp is as full as possible with such virtual sites.  Performing
        // this placement with the standalone kernel will replace the virtual site positions in
        // the global arrays that the underlying PhaseSpaceSynthesis deems "current." If the
        // placement is part of a broader valence work unit, the placement will go into global
        // arrays for coordinates that the underlying PhaseSpaceSynthesis deems "future."
#ifdef VSITE_STANDALONE
        const int manip_llim    = vwu_map[(size_t)(VwuAbstractMap::MANIPULATE)].x;
        const int manip_segment = (vs_atom >> warp_bits);
        const int manip_bitpos  = (vs_atom & warp_bits_mask_int); 
        const uint2 manip_mask = poly_auk.vwu_manip[manip_llim + manip_segment];
        if ((manip_mask.y >> manip_bitpos) & 0x1) {
          const size_t write_idx = __ldca(&poly_vk.vwu_imports[import_llim + vs_atom]);
#  ifdef TCALC_IS_SINGLE
#    ifdef SPLIT_FORCE_ACCUMULATION
          const llint x_tmp = int63ToLongLong(sh_xfrc[vs_atom], sh_xfrc_overflow[vs_atom]);
          const llint y_tmp = int63ToLongLong(sh_yfrc[vs_atom], sh_yfrc_overflow[vs_atom]);
          const llint z_tmp = int63ToLongLong(sh_zfrc[vs_atom], sh_zfrc_overflow[vs_atom]);
          __stwb(&poly_psw.xalt[write_idx], x_tmp);
          __stwb(&poly_psw.yalt[write_idx], y_tmp);
          __stwb(&poly_psw.zalt[write_idx], z_tmp);
#    else
          __stwb(&poly_psw.xalt[write_idx], sh_xfrc[vs_atom]);
          __stwb(&poly_psw.yalt[write_idx], sh_yfrc[vs_atom]);
          __stwb(&poly_psw.zalt[write_idx], sh_zfrc[vs_atom]);
#    endif
#  else
          __stwb(&poly_psw.xalt[write_idx], sh_xfrc[vs_atom]);
          __stwb(&poly_psw.yalt[write_idx], sh_yfrc[vs_atom]);
          __stwb(&poly_psw.zalt[write_idx], sh_zfrc[vs_atom]);
          __stwb(&poly_psw.xalt_ovrf[write_idx], sh_xfrc_overflow[vs_atom]);
          __stwb(&poly_psw.yalt_ovrf[write_idx], sh_yfrc_overflow[vs_atom]);
          __stwb(&poly_psw.zalt_ovrf[write_idx], sh_zfrc_overflow[vs_atom]);
#  endif
        }
#endif
      }
      pos += blockDim.x;
    }

    // If the above block of code is called in the context of a valence work unit kernel, the
    // necessary synchronization will be handled in that kernel.
#ifdef VSITE_STANDALONE

    // No asynchronous scheduling will be provided for advancing work units that merely place
    // virtual sites.  If the placement is done as part of the valence work units, which it will
    // be in the dynamics applications that make up the more common use cases, the work units will
    // advance with the valence counter of a MolecularMechanicsControls object.
    __syncthreads();
    if (threadIdx.x == 0) {
      vwu_idx += gridDim.x;
    }
    __syncthreads();
  }
}
#endif

// Un-define the valence block's atom capacity and an L1 access index macro.
#ifdef VSITE_STANDALONE
#  undef EXCL_GMEM_OFFSET
#  undef VALENCE_ATOM_CAPACITY
#endif
