// -*-c++-*-
#ifndef STORMM_MESH_FOUNDATION_H
#define STORMM_MESH_FOUNDATION_H

#include "copyright.h"
#include "Accelerator/gpu_details.h"
#include "Accelerator/hybrid.h"
#include "Accelerator/mesh_kernel_manager.h"
#include "Constants/behavior.h"
#include "Topology/atomgraph.h"
#include "Trajectory/coordinateframe.h"
#include "Trajectory/coordinate_series.h"
#include "mesh_parameters.h"
#include "mesh_rulers.h"

namespace stormm {
namespace structure {

using card::Hybrid;
using card::HybridTargetLevel;
using card::MeshKlManager;
using constants::PrecisionModel;
using topology::AtomGraph;
using trajectory::CoordinateFrame;
using trajectory::CoordinateSeries;
  
/// \brief Abstract for the MeshFoundation object to encapsulate pointers to its data on the host
///        or the device.
struct MeshBasicsKit {

  /// \brief The constructor takes arguments for each of the handful of member variables.
  MeshBasicsKit(const int* ngbr_in, const size_t* ngbr_bounds_in, const uint* frozen_atoms_in);

  /// \brief As with most abstracts, the presence of const members implies that the copy and move
  ///        assignment operators are deleted, but the default copy and move constructors are
  ///        acceptable.
  /// \{
  MeshBasicsKit(const MeshBasicsKit &original) = default;
  MeshBasicsKit(MeshBasicsKit &&original) = default;
  /// \}

  // Member variables
  const int* ngbr;            ///< Concatenated lists of neighbor atoms
  const size_t* ngbr_bounds;  ///< Bounds array for the neighbor lists in ngbr
  const uint* frozen_atoms;   ///< A mask for frozen atoms in the referenced topology, included
                              ///<   convenience in GPU-based mapping operations.
};
  
/// \brief A small object to hold the essential descriptors of the molecule
class MeshFoundation {
public:

  /// \brief The constructor accepts a topology some form of coordinates.  It is overloaded to
  ///        accept various valid coordinate objects.
  /// \{
  MeshFoundation(const CoordinateFrame *cf_in = nullptr, const AtomGraph *ag_in = nullptr,
                 const std::vector<std::string> &comments = {1, "Generated by STORMM"});

  MeshFoundation(const CoordinateFrame &cf, const AtomGraph &ag_in,
                 const std::vector<std::string> &comments = {1, "Generated by STORMM"});

  template <typename T>
  MeshFoundation(const CoordinateSeries<T> *cs, const AtomGraph *ag_in = nullptr, 
                 const std::vector<std::string> &comments = {1, "Generated by STORMM"});

  template <typename T>
  MeshFoundation(const CoordinateSeries<T> &cs, const AtomGraph &ag_in,
                 const std::vector<std::string> &comments = {1, "Generated by STORMM"});
  /// \}

  /// \brief Get an indication of whether the object has enough information to direct the
  ///        construction of a mesh.
  int getReadyFrameCount() const;
  
  /// \brief Get a const pointer to the topology responsible for creating the associated mesh.
  const AtomGraph* getTopologyPointer() const;

  /// \brief Get a const pointer to the coordinates responsible for creating the associated mesh.
  const CoordinateFrame* getCoordinatePointer() const;

  /// \brief Get a const reference to the array of structures (each stored as a CoordinateFrame)
  ///        reponsible for creating the associated mesh.
  template <typename Tcoord>
  const CoordinateSeries<Tcoord>* getEnsemblePointer() const;

  /// \brief Get the codified data type of the ensemble.
  size_t getEnsembleTypeCode() const;

  /// \brief Get the frozen atom mask.
  std::vector<uint> getFrozenAtomMask() const;

  /// \brief Get the number of comments appended to the mesh.
  int getCommentCount() const;

  /// \brief Get a comment from the list in the mesh.
  ///
  /// \param comm_index  The index of the comment to retrieve (this will be checked for validity)
  const std::string& getComment(int comm_index) const;
  
  /// \brief Get the object's abstract.
  ///
  /// \param tier  Indicate whether to target pointers to memory on the CPU host or GPU device
  MeshBasicsKit data(HybridTargetLevel tier = HybridTargetLevel::HOST) const;

#ifdef STORMM_USE_HPC
  /// \brief Upload the relevant data to the GPU device.
  void upload();

  /// \brief Download the relevant data from the GPU device.
  void download();
  
#  ifdef STORMM_USE_CUDA
  /// \brief Get an abstract for the objet's host-mapped data visible from the device.
  MeshBasicsKit deviceViewToHostData(HybridTargetLevel tier = HybridTargetLevel::HOST) const;
#  endif
#endif

  /// \brief Set the topology that the mesh shall use.  This will allocate and populate the Hybrid
  ///        array pertaining to the frozen atoms mask.  All other mesh data is resized as needed
  ///        by the allocate() member function.
  ///
  /// \param ag_in  Pointer to the topology of interest
  void setTopology(const AtomGraph *ag_in);

  /// \brief Set the coordinates that the mesh shall use.
  ///
  /// Overloaded:
  ///   - Supply the coordinates by const pointer
  ///   - Supply the coordinates by const reference
  ///
  /// \param cf_in  Pointer or reference to the coordinates of interest
  /// \{
  void setCoordinates(const CoordinateFrame *cf_in);
  void setCoordinates(const CoordinateFrame &cf_in);
  /// \}

  /// \brief Set the series of coordinates that the mesh shall use.
  ///
  /// Overloaded:
  ///   - Supply the coordinates by const pointer
  ///   - Supply the coordinates by const reference
  ///
  /// \param cs_in  Pointer or reference to the coordinates of interest
  /// \{
  template <typename Tcoord> void setEnsemble(const CoordinateSeries<Tcoord> *cs_in);
  template <typename Tcoord> void setEnsemble(const CoordinateSeries<Tcoord> &cs_in);
  /// \}
  
  /// \brief Compute neighbor lists for each mesh element, if appropriate for the mesh type.
  ///
  /// \param mps           Parameters for the mesh of interest, to provide context for the
  ///                      coordinates contained in this object
  /// \param rlrs          Pre-computed rulers to aid in ascertaining the location of each atom
  ///                      with standardized precision
  /// \param launcher      Manager for mesh kernels, dispenses launch parameters
  /// \param prec          Precision model to use in GPU-based mesh construction computations
  /// \param availability  Level at which the data is expected to be available
  void computeNeighborLists(const MeshParameters &mps, const MeshRulers &rlrs,
                            const MeshKlManager &launcher = MeshKlManager(),
                            PrecisionModel prec = PrecisionModel::SINGLE,
                            HybridTargetLevel availability = HybridTargetLevel::HOST);

  /// \brief Add a comment to the mesh.
  ///
  /// \param verbiage  The comment to include
  void addComment(const std::string &verbiage);

  /// \brief Clear the list of comments in the mesh.
  void clearComments();
  
private:

  /// Indicate that the object is ready with a valid topology and coordinate object.
  int frames_ready;
  
  /// Pointer to the coordinates responsible for creating the potential
  CoordinateFrame *cf_pointer;

  /// Array of coordinate frames represented on the mesh (the structures in this array will be
  /// aligned as needed to optimize their overlap in some region of interest, such as a binding
  /// site).  This member variable is a pointer to the original coordinate series, reinterpreted as
  /// void to eliminate the need for templating in this object.  See ensemble_data_type below.
  CoordinateSeries<void> *cf_ensemble;

  /// Store the type of the CoordinateSeries after casting its pointer to that of a <void>-type
  /// series.
  size_t ensemble_data_type;

  /// Pointer to the original topology
  AtomGraph *ag_pointer;

  /// Element-wise neighbor lists for nearby frozen atoms
  Hybrid<int> neighbor_list;

  /// Bounds array for the neighbor list atoms array above
  Hybrid<size_t> neighbor_list_bounds;

  /// Snapshot of the frozen atoms in the topology (in case the topology is modified later).  This
  /// is an array of boolean, bitwise values, storing one bit for each atom.  The bits are set to
  /// 1 if the atom is frozen, 0 if the atom is mobile.
  Hybrid<uint> frozen_atoms;

  /// A list of comments describing the mesh, attached to the object after the mesh is created.
  /// These become relevant when printing the mesh to various file formats.
  std::vector<std::string> comments;

  /// \brief Check the consistency of the number of atoms in structures and the topology fed to the
  ///        mesh object.  This function will check for a coordinate series, then a single frame,
  ///        and take the atom count of the first object it finds to then compare to the topology.
  ///        One coordinate pointer and the topology pointer are assumed to be valid prior to
  ///        calling this function.
  int validateAtomCounts() const;

  /// \brief Check whether the object is prepared to direct construction of some mesh object.
  void testReadiness();
};
 
} // namespace structure
} // namespace stormm

#include "mesh_foundation.tpp"

#endif
