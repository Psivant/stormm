// -*-c++-*-
#ifndef STORMM_HPC_DYNAMICS_H
#define STORMM_HPC_DYNAMICS_H

#include <string>
#include "copyright.h"
#include "Accelerator/core_kernel_manager.h"
#include "Accelerator/gpu_details.h"
#include "Constants/behavior.h"
#include "Constants/fixed_precision.h"
#include "MolecularMechanics/mm_controls.h"
#include "Namelists/nml_dynamics.h"
#include "Numerics/numeric_enumerators.h"
#include "Potential/cacheresource.h"
#include "Potential/energy_enumerators.h"
#include "Potential/scorecard.h"
#include "Synthesis/atomgraph_synthesis.h"
#include "Synthesis/implicit_solvent_workspace.h"
#include "Synthesis/nonbonded_workunit.h"
#include "Synthesis/synthesis_enumerators.h"
#include "Synthesis/synthesis_cache_map.h"
#include "Synthesis/systemcache.h"
#include "Synthesis/valence_workunit.h"
#include "Trajectory/motion_sweeper.h"
#include "Trajectory/thermostat.h"
#include "UnitTesting/stopwatch.h"

namespace stormm {
namespace mm {

using card::CoreKlManager;
using card::GpuDetails;
using constants::PrecisionModel;
using energy::CacheResource;
using energy::ScoreCard;
using namelist::DynamicsControls;
using numerics::AccumulationMethod;
using numerics::default_energy_scale_bits;
using synthesis::AtomGraphSynthesis;
using synthesis::ImplicitSolventWorkspace;
using synthesis::maximum_valence_work_unit_atoms;
using synthesis::NbwuKind;
using synthesis::PhaseSpaceSynthesis;
using synthesis::small_block_max_atoms;
using synthesis::StaticExclusionMaskSynthesis;
using synthesis::SynthesisCacheMap;
using synthesis::SystemCache;
using testing::StopWatch;
using trajectory::MotionSweeper;
using trajectory::Thermostat;

/// \brief Run dynamics of all structures in a synthesis based on data contained in a molecular
///        dynamics controls object.
///
/// Overloaded:
///   - Accept minimal arguments and fine the objects internally to construct all necessary
///     abstracts and scratch spaces for the dynamics.  This will return a new energy tracking
///     object generated by the dynamics.
///   - Accept an intermediate level of prepared objects (e.g. the non-bonded exclusions and a
///     thermostat, in addition to basic coordinate and topology data).  Prepare other components,
///     such as implicit solvent data arrays, thread block workspaces, and kernel managers,
///     internally.  This routine will likewise return an energy tracking object with a record
///     of the run.  The topology synthesis is expected to have been uploaded to the GPU.
///
/// \param valence_prec   The precision model in which valence calculations will be carried out
/// \param nonbond_prec   Arithmetic precision by which non-bonded calculations will be carried out
/// \param energy_bits    The number of bits with which energy will be tracked
/// \param poly_ag        The topology synthesis spanning all systems
/// \param poly_se        Static exclusion masks spanning all systems
/// \param tst            The thermostat controlling integration and temperature regulation in all
///                       systems
/// \param poly_ps        Coordinates (positions, velocities, and forces) for all systems
/// \param mos            Hold accumulators and work units for performing system-wide reductions of
///                       net motion of or about the center of mass
/// \param dyncon         User-provided dynamics control input
/// \param mmctrl_fe      Progress counters for molecular mechanics kernels when calculating energy
///                       (forces are always calculated when propagating dynamics)
/// \param mmctrl_fx      Progress counters for molecular mechanics kernels when calculating only
///                       forces
/// \param sc             Energy tracking object
/// \param vale_fe_cache  Thread-block specific cache resources for use in valence calculations and
///                       integration, on steps including energy calculations
/// \param vale_fx_cache  Thread-block specific cache resources for use in valence calculations and
///                       integration, on steps when only the forces are computed
/// \param nonb_fe_cache  Thread-block specific cache resources for use in non-bonded calculations,
///                       on steps including energy calculations
/// \param nonb_fx_cache  Thread-block specific cache resources for use in non-bonded calculations,
///                       on steps when only the forces are computed
/// \param ism_space      Scratch space for implicit solvent calculations
/// \param acc_meth       The accumulation method for forces in valence and non-bonded calculations
/// \param sysc           The original cache of systems provided by user input
/// \param syscmap        A map linking the systems in the cache (where trajectory and checkpoint
///                       file names can be found) to their instances in the coordinate and
///                       topology syntheses
/// \param gpu            Details of the GPU that will run calculations
/// \param launcher       Launch parameters for the core kernels
/// \param timer          Wall time tracker
/// \param task_name      Developer-specified string to assign this dynamics task, i.e. for error
///                       tracing purposes
/// \{
void launchDynamics(PrecisionModel valence_prec, PrecisionModel nonbond_prec,
                    const AtomGraphSynthesis &poly_ag, const StaticExclusionMaskSynthesis &poly_se,
                    Thermostat *tst, PhaseSpaceSynthesis *poly_ps, MotionSweeper *mos,
                    const DynamicsControls &dyncon, MolecularMechanicsControls *mmctrl_fe,
                    MolecularMechanicsControls *mmctrl_fx, ScoreCard *sc,
                    CacheResource *vale_fe_cache, CacheResource *vale_fx_cache,
                    CacheResource *nonb_fe_cache, CacheResource *nonb_fx_cache,
                    ImplicitSolventWorkspace *ism_space, AccumulationMethod acc_meth,
                    const SystemCache &sysc, const SynthesisCacheMap &syscmap,
                    const GpuDetails &gpu, const CoreKlManager &launcher,
                    StopWatch *timer = nullptr, const std::string &task_name = std::string(""));

ScoreCard launchDynamics(const AtomGraphSynthesis &poly_ag,
                         const StaticExclusionMaskSynthesis &poly_se, Thermostat *tst,
                         PhaseSpaceSynthesis *poly_ps, const DynamicsControls &dyncon,
                         const SystemCache &sysc, const SynthesisCacheMap &syscmap,
                         const GpuDetails &gpu,
                         PrecisionModel valence_prec = PrecisionModel::SINGLE,
                         PrecisionModel nonbond_prec = PrecisionModel::SINGLE,
                         int energy_bits = default_energy_scale_bits,
                         StopWatch *timer = nullptr,
                         const std::string &task_name = std::string(""));
/// \}
  
} // namespace mm
} // namespace stormm

#endif
